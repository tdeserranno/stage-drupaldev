<?php

/**
 * @file
 * A module that allows importing of content in JSON format.
 */
/**
 * Custom constants
 */
//Custom FILE_EXISTS, defined more for the ability to change possible multiple occurences from 1 location.
define('CONTENTIMPORT_FILE_SAVE_BEHAVIOR', FILE_EXISTS_REPLACE);

/**
 * Implements hook_help().
 */
function contentimport_help($path, $args) {
  if ($path === 'admin/help#contentimport') {
    return '<p>' . t('A module that allows importing of content in JSON format.') . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function contentimport_menu() {
  $items['import/locate-files'] = array(
    'title' => 'Import content',
    'description' => 'Specify the location of the import files.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('contentimport_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Form builder : contentimport specify files location form.
 */
function contentimport_form($form, &$form_state) {
  $form['files_location'] = array(
    '#type' => 'textfield',
    '#title' => t('Import files location'),
    '#description' => t('Folder names generated by the contentexport module have the following format : contenttype_dd-mm-yyyy'),
    '#size' => 80,
    '#maxlength' => 120,
    '#attributes' => array(
      'placeholder' => 'public://import/<folder name>',
    ),
    '#required' => TRUE,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  return $form;
}

/**
 * Form submit handler : contentimport form.
 */
function contentimport_form_submit($form, &$form_state) {
  $files_location = $form_state['values']['files_location'];
  // Trim trailing slash.
  $files_location = rtrim($files_location, '/');

  // Check if files location exists.
  if (!is_dir($files_location)) {
    drupal_set_message(
        t('The specified location %location does not exist or is not a directory.', array('%location' => $files_location)), 'error');
  }
  else {
    _contentimport_import($files_location);
  }

  // Redirect to import form.
  $form_state['redirect'] = 'import/locate-files';
}

/**
 * Custom function : import data located at given location.
 */
function _contentimport_import($files_location) {
  // Check for JSON file.
  $regex = '/\.json$/';
  $options = array('recurse' => TRUE);
  $json_files = file_scan_directory($files_location, $regex, $options);
//  dpm($json_file);
  if (!empty($json_files)) {
    if (count($json_files) > 1) {
      drupal_set_message('More than one JSON file found.', 'error');
      return;
    }
  }
  else {
    drupal_set_message('No JSON file found.', 'error');
    return;
  }

  // Load JSON data.
  $json_file = array_shift($json_files);
  $json_data = file_get_contents($json_file->uri);
  $json_data = drupal_json_decode($json_data);
//  dpm($json_data);
  // Check import site prerequisites.
  _contentimport_check_prerequisites($json_data, $files_location);

  //  $result = array_values($result);
//  dpm($json_files);
  // Check for image folder.
  $images_location = $files_location . '/image/';
  if (!is_dir($images_location)) {
    drupal_set_message(
        t('No image directory found in %import_directory.', array('%import_directory' => $files_location)), 'error');
//    return;
  }




  // Prepare import data
  $new_nodes = _contentimport_prepare_data($json_data, $images_location);

  // Save new nodes.
  foreach ($new_nodes as $node) {
//    node_save($node);
  }
}

/**
 * Custom function : prepare json_data for import.
 */
function _contentimport_prepare_data(array $import_data, $images_location) {
  $import_nodes = array();
  global $user;
  // Get site's node types.
  $node_types = node_type_get_types();

  // Get site vocabularies.
  $vocabularies = taxonomy_vocabulary_get_names();

  // Cylce through data array.
  foreach ($import_data as $import_row) {
    // Check if node type to be imported exists on the site.
    if (isset($node_types[$import_row['type']])) {
      // Build new node.
      $new_node = new stdClass();
      $new_node->type = $import_row['type'];
      node_object_prepare($new_node);
      $new_node->language = LANGUAGE_NONE;
      $new_node->title = $import_row['title'];
      $new_node->status = (boolean) $import_row['status'];
      $new_node->comment = (integer) $import_row['comment'];
      $new_node->promote = (boolean) $import_row['promote'];
      $new_node->sticky = (boolean) $import_row['sticky'];
      $new_node->body = $import_row['body'];
      $new_node->uid = $user->uid;

      // Determine what field types are present.
      $property_keys = array_keys($import_row);
      $field_keys = preg_grep('/^field_[a-z]*$/', $property_keys);
//    dpm($field_keys);
      // Handle fields.
      foreach ($field_keys as $field) {
        // Get field type.
        $field_info = field_info_field($field);
        // Check if field exists.
        if ($field_info !== NULL) {
          switch ($field_info['type']) {
            case 'image':
              if ($field === 'field_image') {
                $new_node->field_image[$new_node->language] = _contentimport_prepare_images($import_row, $field, $new_node->language, $images_location);
              }
              break;
            case 'taxonomy_term_reference':
              if ($field === 'field_tags') {
                $new_node->field_tags[$new_node->language] = _contentimport_prepare_taxonomy($import_row, $field, $new_node->language, $vocabularies);
              }
              break;

            default:
              drupal_set_message(t('Import for %field not handled.', array('%fieldtype' => $field_info['name'])), 'warning');
              break;
          }
        }
        else {
          // Do something, field does not exist.
          // For the moment, inform user.
          drupal_set_message(t('Field %field does not exist. Data not imported.', array('%field' => $field)), 'warning');
        }
      }

      // Submit node.
      $import_nodes[] = node_submit($new_node);
    }
    else {
      drupal_set_message(t('Content type %type not available for import.', array('%type' => $import_row['type'])), 'error');
    }
  }
  dpm($import_nodes);

  return $import_nodes;
}

/**
 * Custom function : handle field type image import.
 */
function _contentimport_prepare_images($import_row, $field, $language, $images_location) {
  $new_images = array();
  // Check if field array isn't empty.
  if (isset($import_row[$field][$language]) && !empty($import_row[$field][$language])) {
    // Cycle through field array.
    foreach ($import_row[$field][$language] as $import_image) {
      // Build path to import file.
      $pattern = 'public://field/image/';
      $replacement = rtrim($images_location, '/');
      $replacement = $replacement . '/';
      $import_uri = str_replace($pattern, $replacement, $import_image['uri']);

      // Check/create destination directory.
      // Cut filename off of file uri.
      $pattern = '/\/\w+\.[a-z]{3,4}$/';
      $directory = preg_replace($pattern, '', $import_image['uri']);
      if (!file_prepare_directory($directory, FILE_MODIFY_PERMISSIONS | FILE_CREATE_DIRECTORY)) {
        drupal_set_message(t('Failed to create destination directory %directory, or is not writable.', array('%directory' => $directory)), 'error');
      }
      else {
        // Open import file and save as managed file.
        $file_data = file_get_contents($import_uri);
        $destination = $import_image['uri'];
        // CHANGE BACK TO FILE EXISTS RENAME !!!
        $file = file_save_data($file_data, $destination, CONTENTIMPORT_FILE_SAVE_BEHAVIOR);

        // Convert stdClass to assoc array.
        $file = json_decode(json_encode($file), TRUE);

        // Add additional data.
        $file['alt'] = $import_image['alt'];
        $file['title'] = $import_image['title'];
        $file['width'] = $import_image['width'];
        $file['height'] = $import_image['height'];

        // Add new file to array.
        $new_images[] = $file;
      }
    }
  }
  return $new_images;
}

/**
 * Custom function : handle field type taxonomy term reference import.
 */
function _contentimport_prepare_taxonomy($import_row, $field, $language, $vocabularies) {
  $new_terms = array();
  $new_tids = array();
  // Check if the field array isn't empty
  if (isset($import_row[$field][$language]) && !empty($import_row[$field][$language])) {
    // Cycle through field array.
    foreach ($import_row[$field][$language] as $row_term) {
      // Check if term exists.
      $matching_terms = taxonomy_get_term_by_name($row_term['name'], $row_term['vocabulary_machine_name']);
      if (empty($matching_terms)) {
        // Get vocabulary id for new term.
        $term_vid = _contentimport_get_vocabulary_id($vocabularies, $row_term['vocabulary_machine_name']);
        if ($term_vid !== FALSE) {
          // Vocabulary exists, create term.
          $term = new stdClass();
          $term->vid = $term_vid;
          $term->name = $row_term['name'];
          $term->description = $row_term['description'];
          $term->format = $row_term['format'];
          $term->weight = $row_term['weight'];
          $term->vocabulary_machine_name = $row_term['vocabulary_machine_name'];

          // Add new term to array.
          $new_terms[] = $term;
        }
        else {
          // Vocabulary does not exist, inform user.
          drupal_set_message(t('Vocabulary %vocabulary for term %term does not exist, term not imported.', array(
            '%vocabulary' => $row_term['vocabulary_machine_name'],
            '%term' => $row_term['name'],
              )), 'warning');
        }
      }
      else {
        // Term already exists.
//        drupal_set_message(t('Vocabulary %vocabulary already contains a term called %term, term not imported.', array(
//            '%vocabulary' => $row_term['vocabulary_machine_name'],
//            '%term' => $row_term['name'],
//              )), 'warning');
        $keys = array_keys($matching_terms);
        if (count($keys) > 1) {
          drupal_set_message(t('More than 1 matching term for %term in vocabulary %vocabulary, unable to assign term to node.', array(
            '%vocabulary' => $row_term['vocabulary_machine_name'],
            '%term' => $row_term['name'],
              )), 'error');
        }
        else {
          $new_tids[] = $keys[0];
        }
      }
    }
  }

  // Create each new term and construct tid array to return.
  foreach ($new_terms as $new_term) {
    taxonomy_term_save($new_term);
    $new_tids[] = array(
      'tid' => $new_term->tid,
    );
  }

  return $new_tids;
}

/**
 * Custom function : checks if vocabulary exists and returns its vid. Returns FALSE if not found.
 */
function _contentimport_get_vocabulary_id($vocabularies, $search_machine_name) {
  $vid = FALSE;
  foreach ($vocabularies as $vocabulary) {
    if ($vocabulary->machine_name === $search_machine_name) {
      $vid = $vocabulary->vid;
      break;
    }
  }

  return $vid;
}

/**
 * Custom function : check prerequisites on in import site.
 */
function _contentimport_check_prerequisites($json_data, $files_location) {
  $prerequisites = array();

  // Cycle through JSON data.
  foreach ($json_data as $json_row) {
    // Check if content type exists if the flag has not been set already.
    // As the export is for one content type only this should happen on the first cycle.
    if (!isset($prerequisites['content_type'])) {
      $prerequisites['content_type'] = node_type_get_type($json_row['type']);
    }
    // Following checks should not happen if content type was not found.
    if ($prerequisites['content_type'] !== FALSE) {
      // Check missing fields, stop checking if already set.
      if (!isset($prerequisites['missing_fields'])) {
        // Get fields of content type.
        $prerequisites['fields'] = field_read_fields(array(
          'entity_type' => 'node',
          'bundle' => $prerequisites['content_type']->type,
        ));
//      dpm($fields);
        // Determine what custom fields are present in json data.
        $json_row_keys = array_keys($json_row);
        $json_field_keys = preg_grep('/^field_[a-z]*$/', $json_row_keys);
        dpm($json_field_keys);
        // Compare with json data to find missing fields.
        $field_names = array_keys($prerequisites['fields']);

        $prerequisites['missing_fields'] = array_diff($json_field_keys, $field_names);
      }
      // Check if any of the json rows have images, set the flag if it hasn't been set already.
      if (!isset($prerequisites['images'])) {
        //Cycle through fields.
        foreach ($prerequisites['fields'] as $field) {
          // If fieldtype is image, check if json array is empty.
          if ($field['type'] === 'image') {
            
          }
        }
//      if (!empty($json_row)) {
//        // Do something.
//      }
      }
    }
  }
  dpm($prerequisites);
}
