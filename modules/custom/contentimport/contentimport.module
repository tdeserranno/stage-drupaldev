<?php

/**
 * @file
 * A module that allows importing of content in JSON format.
 */
/**
 * Custom constants
 */
//Custom FILE_EXISTS, defined more for the ability to change possible multiple occurences from 1 location.
define('CONTENTIMPORT_FILE_SAVE_BEHAVIOR', FILE_EXISTS_REPLACE);
define('CONTENTIMPORT_IMG_FILE_REGEX', '/[\w\s\-]+\.(jpg|png|jpeg|gif)$/');
define('CONTENTIMPORT_JSON_FILE_REGEX', '/[\w\s\-]+\.json$/');
define('CONTENTIMPORT_ERRORLOG_URI', 'public://import/log/error.txt');

/**
 * Implements hook_help().
 */
function contentimport_help($path, $args) {
  if ($path === 'admin/help#contentimport') {
    return '<p>' . t('A module that allows importing of content in JSON format.') . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function contentimport_menu() {
  $items['admin/import/locate-files'] = array(
    'title' => 'Import content',
    'description' => 'Specify the location of the import files.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('contentimport_fileslocation_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/import/warnings'] = array(
    'title' => 'Import warnings',
    'page callback' => '_contentimport_warning_page',
    'access arguments' => array('access administration pages'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Form builder : specify the location of the import files.
 */
function contentimport_fileslocation_form($form, &$form_state) {
  $form['files_location'] = array(
    '#type' => 'textfield',
    '#title' => t('Import files location'),
    '#description' => t('Folder names generated by the contentexport module have the following format : contenttype_dd-mm-yyyy'),
    '#size' => 80,
    '#maxlength' => 120,
    '#attributes' => array(
      'placeholder' => 'public://import/<folder name>',
    ),
    '#required' => TRUE,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  return $form;
}

/**
 * Form submit handler : contentimport_fileslocation_form.
 */
function contentimport_fileslocation_form_submit($form, &$form_state) {
  // Begin import process.
  _contentimport_begin_import($form_state['values']['files_location']);

  // Redirect to import form.
  $form_state['redirect'] = 'admin/import/locate-files';
}

/**
 * Form validation : contentimport_fileslocation_form.
 */
function contentimport_fileslocation_form_validate($form, &$form_state) {
  $files_location = $form_state['values']['files_location'];
  // Trim trailing slash.
  $files_location = rtrim($files_location, '/');

  // Check if files location exists.
  if (!is_dir($files_location)) {
    form_set_error(
        'files_location', t('The specified location %location does not exist or is not a directory.', array('%location' => $files_location)));
  }
}

/**
 * Custom function : conduct initial checks before import.
 */
function _contentimport_begin_import($files_location) {
  // Check for JSON file.
  $options = array('recurse' => TRUE);
  $json_files = file_scan_directory($files_location, CONTENTIMPORT_JSON_FILE_REGEX, $options);
//  dpm($json_file, 'result of file scan for json file');
  if (!empty($json_files)) {
    if (count($json_files) > 1) {
      drupal_set_message('More than one JSON file found.', 'error');
      return;
    }
  }
  else {
    drupal_set_message('No JSON file found.', 'error');
    return;
  }

  // Load JSON data.
  $json_file = array_shift($json_files);
  $json_data = file_get_contents($json_file->uri);
  $json_data = drupal_json_decode($json_data);
//  dpm($json_data, 'decoded import data');
  // Check import site requirements.
  $requirements = _contentimport_generate_requirements($json_data, $files_location);

  // Evaluate requirements and take appropriate action.
  $warnings = _contentimport_evaluate_requirements($requirements);
  // If warnings not empty go to warnings form, otherwise continue import
  if (!empty($warnings)) {
    // Query contentimport_remember table for this import location.
    $query = db_select('contentimport_remember', 'cir')
        ->fields('cir', array('import_location'))
        ->condition('import_location', $files_location)
        ->range(0, 1);
    $ignore_location = $query->execute()->fetchCol();

    // Check if warnings need to be ignored.
    if (empty($ignore_location)) {
      // Store variables in SESSION
      $_SESSION['contentimport']['warnings'] = $warnings;
      $_SESSION['contentimport']['files_location'] = $files_location;
      $_SESSION['contentimport']['json_data'] = $json_data;
      $_SESSION['contentimport']['requirements'] = $requirements;
      // Go to warnings page.
      drupal_goto('admin/import/warnings');
    }
    else {
      // Ignore warnings and continue import.
      _contentimport_import($json_data, $requirements);
    }
  }
  else {
    // Continue import
    _contentimport_import($json_data, $requirements);
  }
}

/**
 * Custom function : start actual import process.
 */
function _contentimport_import($json_data, $requirements) {
  $filesize_before = FALSE;
  // Get filesize of error log
  if (file_exists(CONTENTIMPORT_ERRORLOG_URI)) {
    $new_file = FALSE;
    $filesize_before = filesize(CONTENTIMPORT_ERRORLOG_URI);
  }

  // Prepare import data
  $new_nodes = _contentimport_prepare_data($json_data, $requirements);
//  dpm($new_nodes, 'New nodes');
  // Save new nodes.
  foreach ($new_nodes as $node) {
    node_save($node);
  }

  // Compare filesize of error log
  if ($filesize_before === FALSE) {
    if (file_exists(CONTENTIMPORT_ERRORLOG_URI)) {
      $new_file = TRUE;
      $filesize_before = filesize(CONTENTIMPORT_ERRORLOG_URI);
    }
  }

  if ($filesize_before !== FALSE) {
    $filesize_after = filesize(CONTENTIMPORT_ERRORLOG_URI);
    dpm($filesize_before, 'filesize before');
    dpm($filesize_after, 'filesize after');
    if (($filesize_after > $filesize_before) || ($filesize_after === $filesize_before && $new_file === TRUE)) {
      $url = file_create_url(CONTENTIMPORT_ERRORLOG_URI);
      drupal_set_message(t('Some errors have occurred, see the error log for details !url.', array('!url' => l('here', $url))), 'warning');
    }
  }

  // SESSION cleanup
  if (isset($_SESSION['contentimport'])) {
    unset($_SESSION['contentimport']);
  }
}

/**
 * Custom function : prepare json_data for import.
 */
function _contentimport_prepare_data(array $import_data, $requirements) {
  $import_nodes = array();
  global $user;

  // Get site's node types. EDIT: no longer needed? checked by requirements?
//  $node_types = node_type_get_types();
  // Get site vocabularies.
  $vocabularies = taxonomy_vocabulary_get_names();

  // Cylce through data array.
  foreach ($import_data as $import_row) {
    // Build new node.
    $new_node = new stdClass();
    $new_node->type = $import_row['type'];
    node_object_prepare($new_node);
    // Set specific language.
    if (isset($import_row['language']) && !empty($import_row['language'])) {
      $new_node->language = $import_row['language'];
    }
    else {
      $new_node->language = LANGUAGE_NONE;
    }
    $new_node->title = $import_row['title'];
    $new_node->status = (boolean) $import_row['status'];
    $new_node->comment = (integer) $import_row['comment'];
    $new_node->promote = (boolean) $import_row['promote'];
    $new_node->sticky = (boolean) $import_row['sticky'];
    $new_node->body = $import_row['body'];
    $new_node->uid = $user->uid;

    // Filter fields that don't require special handling.
    if (isset($requirements['fields']['body'])) {
      unset($requirements['fields']['body']);
    }

    // Handle fields.
    // ? Necessary to handle each language or only the language of the node ?
    foreach ($requirements['fields'] as $field) {
      // Nested switches because im not sure of what will happen when there are more than 1 of image type.
      // Also behavior of the export module is a factor, namely the location where the image files are copied to.
      // Therefor nesting switch to isolate each image type, giving the possibility to supply different
      // image_locations but requiring seperate handling for each field.
      // SUBJECT TO CHANGE IN THE FUTURE
      switch ($field['type']) {
        case 'image':
          switch ($field['field_name']) {
            case 'field_image':
              // ! enclose dynamic property names in {}
              $new_node->{$field['field_name']}[$new_node->language] = _contentimport_prepare_images($import_row, $field['field_name'], $new_node->language, $requirements['image_files']);
              break;
            case 'field_thumbnail':
              // ! enclose dynamic property names in {}
              $new_node->{$field['field_name']}[$new_node->language] = _contentimport_prepare_images($import_row, $field['field_name'], $new_node->language, $requirements['image_files']);
              break;

            default:
              _contentimport_field_not_handled($field['field_name'], $field['type']);
              break;
          }
          break;
        case 'taxonomy_term_reference':
          // ! enclose dynamic property names in {}
          $new_node->{$field['field_name']}[$new_node->language] = _contentimport_prepare_taxonomy($import_row, $field['field_name'], $new_node->language, $vocabularies);
          break;

        default:
          _contentimport_field_not_handled($field['field_name'], $field['type']);
          break;
      }
    }

    // Submit node.
    $import_nodes[] = node_submit($new_node);
  }
//  dpm($import_nodes, 'nodes to import');

  return $import_nodes;
}

/**
 * Custom function : handle field type image import.
 */
function _contentimport_prepare_images($import_row, $field_name, $language, $images) {
  $new_images = array();
  $import_image_uris = array_keys($images);

  // Check if field array isn't empty.
  if (isset($import_row[$field_name][$language]) && !empty($import_row[$field_name][$language])) {
    // Cycle through field array.
    foreach ($import_row[$field_name][$language] as $import_image) {
      // Build destination directory uri
      // Isolate destination directory
      $destination_directory = preg_replace(CONTENTIMPORT_IMG_FILE_REGEX, '', $import_image['uri']);

      // Check writable/Create destination directory.
      if (!file_prepare_directory($destination_directory, FILE_MODIFY_PERMISSIONS | FILE_CREATE_DIRECTORY)) {
        drupal_set_message(t('Failed to create destination directory %directory, or is not writable.', array('%directory' => $destination_directory)), 'error');
      }
      else {
        // Search import image file list for filename matching import data
        $filename = str_replace($destination_directory, '', $import_image['uri']);
        $pattern = '/' . $filename . '$/';
        $matches = preg_grep($pattern, $import_image_uris);
        // On single match, copy file; otherwise display multimatch error
        if (count($matches) === 1) {
          $file_uri = array_shift($matches);
          // Open import file and save as managed file.
          $file_data = file_get_contents($file_uri);
          $destination = $import_image['uri'];
          $file = file_save_data($file_data, $destination, CONTENTIMPORT_FILE_SAVE_BEHAVIOR);

          // Convert stdClass to associative array.
          $file = json_decode(json_encode($file), TRUE);

          // Add additional data.
          $file['alt'] = $import_image['alt'];
          $file['title'] = $import_image['title'];
          $file['width'] = $import_image['width'];
          $file['height'] = $import_image['height'];

          // Add new file to array.
          $new_images[] = $file;
        }
        else {
          drupal_set_message(t('No single match for file %filename, file not created.', array('%filename' => $filename)), 'error');
        }
      }
    }
  }
  return $new_images;
}

/**
 * Custom function : handle field type taxonomy term reference import.
 */
function _contentimport_prepare_taxonomy($import_row, $field_name, $language, $vocabularies) {
  $new_terms = array();
  $new_tids = array();
  $errors = array();

  // Check if the field array isn't empty
  if (isset($import_row[$field_name][$language]) && !empty($import_row[$field_name][$language])) {
    // Cycle through field array.
//    dpm($import_row[$field_name][$language], 'array of taxonomy terms to import');
    foreach ($import_row[$field_name][$language] as $row_term) {
      // Check if term exists.
      $matching_terms = taxonomy_get_term_by_name($row_term['name'], $row_term['vocabulary_machine_name']);
      if (empty($matching_terms)) {
        // Get vocabulary id for new term.
        $term_vid = _contentimport_get_vocabulary_id($vocabularies, $row_term['vocabulary_machine_name']);
        if ($term_vid !== FALSE) {
          // Vocabulary exists, create term.
          $term = new stdClass();
          $term->vid = $term_vid;
          $term->name = $row_term['name'];
          $term->description = $row_term['description'];
          $term->format = $row_term['format'];
          $term->weight = $row_term['weight'];
          $term->vocabulary_machine_name = $row_term['vocabulary_machine_name'];

          // Add new term to array.
          $new_terms[] = $term;
        }
        else {
          // Vocabulary does not exist, inform user.
          drupal_set_message(t('Vocabulary %vocabulary for term %term does not exist, term not imported.', array(
            '%vocabulary' => $row_term['vocabulary_machine_name'],
            '%term' => $row_term['name'],
              )), 'warning');
        }
      }
      else {
        // Term already exists.
        // What to do when there are 2 terms with the same name in the same vocabulary ????
        // Problem is most likely a result of devel generate, unlikely to occur in RL??
        $keys = array_keys($matching_terms);
        if (count($keys) > 1) {
//          drupal_set_message(t('More than 1 matching term for %term in vocabulary %vocabulary, term assigned to first match.', array(
//            '%vocabulary' => $row_term['vocabulary_machine_name'],
//            '%term' => $row_term['name'],
//              )), 'warning');
//          $errors[] = t('More than 1 matching term for %term in vocabulary %vocabulary when importing node %note_title, term assigned to first match.', array(
//            '%vocabulary' => $row_term['vocabulary_machine_name'],
//            '%term' => $row_term['name'],
//            '%node_title' => $import_row['title'],
//          ));
          $term = $row_term['name'];
          $vocabulary = $row_term['vocabulary_machine_name'];
          $node_title = $import_row['title'];
          $errors[] = "More than 1 matching term $term for  in vocabulary $vocabulary when importing node $node_title, term assigned to first match.";
        }
        $new_tids[] = array(
          'tid' => $keys[0],
        );
      }
    }
  }

  // Create each new term and construct tid array to return.
  foreach ($new_terms as $new_term) {
    taxonomy_term_save($new_term);
    $new_tids[] = array(
      'tid' => $new_term->tid,
    );
  }

  // Log any errors
  if (!empty($errors)) {
    $error_link = _contentimport_log_errors($errors);
    if ($error_link === FALSE) {
      drupal_set_message(t('Failed to log errors.'), 'error');
    }
  }
  return $new_tids;
}

/**
 * Custom function : checks if vocabulary exists and returns its vid. Returns FALSE if not found.
 */
function _contentimport_get_vocabulary_id($vocabularies, $search_machine_name) {
  $vid = FALSE;
  foreach ($vocabularies as $vocabulary) {
    if ($vocabulary->machine_name === $search_machine_name) {
      $vid = $vocabulary->vid;
      break;
    }
  }

  return $vid;
}

/**
 * Custom function : check requirements on import site.
 */
function _contentimport_generate_requirements($json_data, $files_location) {
  $requirements = array();
  // Flags default values
  $requirements['image_files'] = FALSE;

  // Cycle through JSON data.
  foreach ($json_data as $json_row) {
    // Check if content type exists if the flag has not been set already.
    // As the export is for one content type only this should happen only on the first loop.
    if (!isset($requirements['content_type'])) {
      $requirements['content_type'] = node_type_get_type($json_row['type']);
    }

    // If the content type is not available the import should abort and therefor 
    // the following checks do not need to be run.
    if (isset($requirements['content_type']) && $requirements['content_type'] !== FALSE) {
      // Get available fields. Fields are dependent on the available content type. 
      // As the export is of one content type only, this only needs to be checked once.
      $requirements['fields'] = _contentimport_requirements_set_fields($requirements['content_type']->type);

      // Compare available fields to fields listed in json data to find any missing fields.
      // Again this only needs to be checked once.
      if (!isset($requirements['missing_fields'])) {
        $requirements['missing_fields'] = _contentimport_requirements_compare_fields($requirements['fields'], $json_row);
      }

      // Scan files location for image files
      $options = array('recurse' => TRUE);
      $requirements['image_files'] = file_scan_directory($files_location, CONTENTIMPORT_IMG_FILE_REGEX, $options);
    }
  }
//    dpm($requirements, 'complete requirements');

  return $requirements;
}

/**
 * Custom function : create render array for warnings page + form
 */
function _contentimport_warning_page() {
  if (isset($_SESSION['contentimport']['warnings'])) {
    // Get variables from SESSION
    $warnings = $_SESSION['contentimport']['warnings'];
    $json_data = $_SESSION['contentimport']['json_data'];
    $requirements = $_SESSION['contentimport']['requirements'];
    $files_location = $_SESSION['contentimport']['files_location'];

    $render_array = array();

    // Warnings.
//      dpm($warnings, 'warnings retrieved from session');
    // Missing fields.
    if (isset($warnings['missing_fields']) && !empty($warnings['missing_fields'])) {
      $render_array['warnings']['missing_fields'] = array(
        '#theme' => 'item_list',
        '#items' => $warnings['missing_fields'],
      );
    }
    // Images.
    if (isset($warnings['images_location'])) {
      $render_array['warnings']['images_location'] = array(
        '#markup' => $warnings['images_location'],
      );
    }
    if (isset($warnings['image_files'])) {
      $render_array['warnings']['image_files'] = array(
        '#markup' => $warnings['image_location'],
      );
    }

    // Form.
    $render_array['form'] = drupal_get_form('contentimport_warning_form', $files_location, $json_data, $requirements);

    return $render_array;
  }
  else {
    // Warnings not set in SESSION, something went terribly wrong here ...
    drupal_set_message(t('Warnings page was called but no warnings were stored in session. Import was halted.'), 'error');
    drupal_goto('admin/import/locate-files');
  }
}

/**
 * Form builder : import warning form.
 */
function contentimport_warning_form($form, &$form_state) {
  // Store files location for use in submit handler.
  $form_state['storage']['files_location'] = $form_state['build_info']['args'][0];
  $form_state['storage']['json_data'] = $form_state['build_info']['args'][1];
  $form_state['storage']['requirements'] = $form_state['build_info']['args'][2];

  // Build form.
  $form['remember_choice'] = array(
    '#type' => 'checkbox',
    '#title' => t('Remember your choice for future imports from this file location?'),
    '#default_value' => 0,
  );

  $question = t('Are you sure you want to continue the import despite these warnings?');
  $path = 'import/locate-files';
  $description = t('Resulting nodes will not have all the information available in the import file.');
  $yes = t('Continue');
  return confirm_form($form, $question, $path, $description, $yes);
}

/**
 * Form submit : contentimport_warning_form.
 */
function contentimport_warning_form_submit($form, &$form_state) {
  // Get variables from storage
  $import_location = $form_state['storage']['files_location'];
  $json_data = $form_state['storage']['json_data'];
  $requirements = $form_state['storage']['requirements'];

  // Check if checkbox was checked.
  if ($form_state['values']['remember_choice'] == TRUE) {
    // Add entry in contentimport_remember table
    $query = db_insert('contentimport_remember')
        ->fields(array('import_location' => $import_location))
        ->execute();
  }

  // Continu import.
  _contentimport_import($json_data, $requirements);

  // Redirect to import form.
  $form_state['redirect'] = 'admin/import/locate-files';
}

/**
 * Custom function : display message if field isn't handled for import.
 */
function _contentimport_field_not_handled($name, $type) {
  drupal_set_message(t('Import for %field of type %field_type not handled.', array(
    '%field' => $name,
    '%field_type' => $type,
      )), 'warning');
}

/**
 * Custom function : evaluates data in $requirements array and takes appropriate
 * action, like aborting the import process or generating a list of warnings.
 * @param array $requirements
 * @return array list of warnings.
 */
function _contentimport_evaluate_requirements($requirements) {
  if ($requirements['content_type'] === FALSE) {
    // Content type is not available, halt import.
    drupal_set_message(t('The content type that you are attempting to import is not available on this site.'), 'error');
    drupal_goto('admin/import/locate-files');
  }
  else {
    // Content type is available, continue import.
    $warnings = array();

    // Check missing fields
    if (!empty($requirements['missing_fields'])) {
      foreach ($requirements['missing_fields'] as $missing_field) {
        $warnings['missing_fields'][$missing_field] = t(
            'The field %field is present in the import data but not available for %contenttype content type on this site.', array(
          '%field' => $missing_field,
          '%contenttype' => $requirements['content_type']->type,
        ));
      }
    }

    // Check if images are used.
    // ! rewrite/delete after review
//    if ($requirements['images'] === TRUE) {
//      // Check if images location is valid.
//      if ($requirements['images_location'] === FALSE) {
//        $warnings['images_location'] = t(
//            'There are images present in the import data but %files_location does not contain an image directory.', array('%files_location', $files_location));
//      }
//      elseif ($requirements['image_files'] === FALSE) {
//        $warnings['image_files'] = t(
//            'There are images present in the import data but the image folder does not contain any image files.');
//      }
//    }

    return $warnings;
  }
}

/**
 * Custom function : returns field info data for all fields of a content type.
 * @param type $content_type
 * @return array field info data of all fields related to content type
 */
function _contentimport_requirements_set_fields($content_type) {
  // Get fields related to content type
  $node_fields = field_info_instances('node', $content_type);
  // Get field info for each field
  foreach ($node_fields as $field) {
    $fields[$field['field_name']] = field_info_field($field['field_name']);
  }

  return $fields;
  // ! field_read_fields function only trustworthy for drupal 7.22 or above
//        $requirements['fields'] = field_read_fields(array(
//          'entity_type' => 'node',
//          'bundle' => $requirements['content_type']->type,
//        ));
//      dpm($fields, 'fields available for content type');
}

/**
 * Custom function : Compares available fields to fields listed in import data
 * and returns an array of field names that are listed in the data but not available.
 * @param array $fields array of field info data keyed by field name
 * @param array $data_row row of json data array, representing 1 node
 * @return array array of field names that are listed in the import data but not 
 *               available for the content type on the current site.
 */
function _contentimport_requirements_compare_fields($fields, $data_row) {
  // Determine what custom fields are present in json data.
  $row_keys = array_keys($data_row);
  $listed_fields = preg_grep('/^field_[a-z]*$/', $row_keys);
//  dpm($json_field_keys, 'array keys in decoded json row matching /^field_[a-z]*$/');
  // Get field names of available fields
  $available_fields = array_keys($fields);

  // Compare with json data to find missing fields.
  return array_diff($listed_fields, $available_fields);
}

/**
 * Custom function : Log export errors in a text file.
 */
function _contentimport_log_errors(array $errors) {
  // Check/Create log directory.
  $directory = 'public://import/log/';
  if (!file_prepare_directory($directory, FILE_MODIFY_PERMISSIONS | FILE_CREATE_DIRECTORY)) {
    drupal_set_message(t('Failed to create directory %directory.', array('%directory' => $directory)), 'error');
    return FALSE;
  }

  // Write errors to log file
  if (!empty($errors)) {
    $file = CONTENTIMPORT_ERRORLOG_URI;
    foreach ($errors as $error) {
      // Build errorstring.
      $errorstring = format_date(REQUEST_TIME, 'custom', 'd-m-Y H:i:s') . ' : ' . $error . PHP_EOL;

      // Write errorstring.
      if (file_put_contents($file, $errorstring, FILE_APPEND | LOCK_EX) === FALSE) {
        drupal_set_message(t('Failed to write %string to error logfile.', array('%string' => $errorstring)), 'error');
        return FALSE;
      }
    }
  }
}
