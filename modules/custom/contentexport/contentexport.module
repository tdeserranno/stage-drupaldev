<?php

/**
 * @file
 * A module that allows exporting of content in JSON format.
 * 
 */
/**
 * Custom constants
 */
//Custom FILE_EXISTS, defined more for the ability to change possible multiple occurences from 1 location.
define('CONTENTEXPORT_FILE_SAVE_BEHAVIOR', FILE_EXISTS_REPLACE);

/**
 * Implements hook_help().
 */
function contentexport_help($path, $args) {
  if ($path === 'admin/help#content_export') {
    return '<p>' . t('A module that allows exporting of content in JSON format.') . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function contentexport_menu() {
  $items['export/select'] = array(
    'title' => 'Export content',
    'description' => 'Export content',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('contentexport_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Form builder : content_export select content type to export.
 */
function contentexport_form($form, &$form_state) {
  $node_types = node_type_get_types();
  $options = array();
  foreach ($node_types as $node_type) {
    $options[$node_type->type] = $node_type->name;
  }

  $form['content_type'] = array(
    '#title' => t('Select content type'),
    '#type' => 'select',
    '#options' => $options,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  return $form;
}

/**
 * Form submit handler : handle contentexport_form.
 */
function contentexport_form_submit($form, &$form_state) {
  $node_type = $form_state['values']['content_type'];

  // Get fields for node_type.
  $fields = field_read_fields(array(
    'entity_type' => 'node',
    'bundle' => $node_type,
  ));
  // Filter out fields that don't need to be checked.
  unset($fields['body']);

  // Load nodes.
  $nodes = _contentexport_get_nodes($node_type, $fields);

  // Export nodes.
  if (!empty($nodes)) {
    dpm($nodes);
    _export_nodes_json_unmanaged($nodes, $fields);
  }
}

/**
 * Custom function : get all nodes of selected type.
 */
function _contentexport_get_nodes($node_type, $fields) {
  $nodes = array();
  // Get nids from database.
  $query = db_select('node', 'n')
      ->fields('n', array('nid', 'type'))
      ->condition('type', $node_type);
  $nids = $query->execute()->fetchCol();

  // Load nodes.
  if (!empty($nids)) {
    $nodes = node_load_multiple($nids);
    dpm($nodes);

    // Create array of field names to test node properties against.
    $field_names = array_keys($fields);

    // Cycle through all nodes to load any extra data, in this case the taxonomy terms.
    // Note: loop values by reference so that it is possible to load the data into the same position of the array.
    foreach ($nodes as &$node) {
      // Cycle through each node property.
      foreach ($node as $property_name => &$property) {
        // Find the field properties.
//        $fieldname_regex = '/^field_[a-z]*$/';
        if (in_array($property_name, $field_names)) {
          // Load the field info for the field.
          $field_info = $fields[$property_name];
//        dpm($field_info);
          // If the field is a taxonomy term reference, load the term.
          if ($field_info['type'] === 'taxonomy_term_reference') {
            if (isset($property['und']) && !empty($property['und'])) {
              foreach ($property['und'] as &$term) {
                $term = taxonomy_term_load($term['tid']);
              }
            }
          }
        }
      }
    }
  }

  return $nodes;
}

/**
 * Custom function : export given nodes to JSON format.
 */
function _export_nodes_json_unmanaged(array $nodes, $fields) {
  // Check if there is actual data to export.
  if (empty($nodes)) {
    // Inform user.
    drupal_set_message(t('Nothing to export.'), 'error');
//    drupal_goto('<front>');
    return;
  }

  // Build data array.
  $file_data = drupal_json_encode($nodes);
//  dpm($file_data);
  // Attempt export.
  $errors = array();
  try {
    $node_keys = array_keys($nodes);
    $first_node = $nodes[$node_keys[0]];

    // Create export directory.
    $directory = 'public://export/' . _export_generate_filename($first_node->type);
    if (!file_prepare_directory($directory, FILE_MODIFY_PERMISSIONS | FILE_CREATE_DIRECTORY)) {
      throw new Exception(t('Failed to create %directory.', array('%directory' => $directory)));
    }

    // Create export image directory.
    $images_directory = 'public://export/' . _export_generate_filename($first_node->type) . '/image';
    if (!file_prepare_directory($images_directory, FILE_MODIFY_PERMISSIONS | FILE_CREATE_DIRECTORY)) {
      throw new Exception(t('Failed to create %directory.', array('%directory' => $images_directory)));
    }

    // Create JSON file.
    $filename = _export_generate_filename($first_node->type, 'json');
    $destination = $directory . '/' . $filename;
    $filename = file_unmanaged_save_data($file_data, $destination, CONTENTEXPORT_FILE_SAVE_BEHAVIOR);
    if ($filename) {
      $url = file_create_url($filename);
      drupal_set_message(t('Saved file as %filename, accessible via !url.', array(
        '%filename' => $filename,
        '!url' => l(t('this URL'), $url),
      )));
    }
    else {
      throw new Exception(t('Failed to save the file.'));
    }

    // Copy node images.
    $image_counter = 0;
    foreach ($nodes as $node) {
      if (isset($node->field_image['und']) && !empty($node->field_image['und'])) {
        foreach ($node->field_image['und'] as $image) {
          if (isset($image['uri']) && !empty($image['uri'])) {
            if (!file_unmanaged_copy($image['uri'], $images_directory, CONTENTEXPORT_FILE_SAVE_BEHAVIOR)) {
              $errors[] = t('Failed to copy %picture', array('%picture' => $image['uri']));
            }
            else {
              $image_counter++;
              // Test copy errors
//              $errors[] = t('Copy error test %picture', array('%picture' => $image['uri']));
            }
          }
        }
      }
    }

    // Notify user.
    if (!empty($errors)) {
      // Log errors.
      if (_contentexport_log_errors($errors) === FALSE) {
        drupal_set_message(t('Error logging failed.'), 'error');
      }
    }
    else {
      if ($image_counter !== 0) {
        drupal_set_message(t('%counter node images copied to %directory', array('%counter' => $image_counter, '%directory' => $images_directory)));
      }
      else {
        drupal_set_message(t('No node images were copied.'));
      }
    }

    // Redirect to front.
    drupal_goto('<front>');
  }
  catch (Exception $exc) {
    // Add exception to errors.
    $errors[] = $exc->getMessage();

    // Log errors.
    _contentexport_log_errors($errors, $exc);

    // Redirect to front.
    drupal_goto('<front>');
  }
}

/**
 * Custom function: Generate filename for export file.
 */
function _export_generate_filename($prefix, $extension = '') {
  $filename = $prefix;
  $filename .= '_' . format_date(time(), 'custom', 'd-m-Y');
  if ($extension !== '') {
    $filename .= '.' . $extension;
  }

  return $filename;
}

/**
 * Custom function : Log export errors.
 */
function _contentexport_log_errors(array $errors, $exception = NULL) {
  // Create log directory.
  $directory = 'public://export/log/';
  if (!file_prepare_directory($directory, FILE_MODIFY_PERMISSIONS | FILE_CREATE_DIRECTORY)) {
    drupal_set_message(t('Failed to create %directory.', array('%directory' => $directory)), 'error');
    return FALSE;
  }

  // Create error log.
  $file = $directory . 'errorlog.txt';
  if (!empty($errors)) {
    foreach ($errors as $error) {
      // Build errorstring.
      $errorstring = format_date(REQUEST_TIME, 'custom', 'd-m-Y H:i:s') . ' : ' . $error . PHP_EOL;

      // Write errorstring.
      if (file_put_contents($file, $errorstring, FILE_APPEND | LOCK_EX) === FALSE) {
        drupal_set_message(t('Failed to write %string to error logfile.', array('%string' => $errorstring)), 'error');
        return FALSE;
      }
    }
  }

  // Notify user about fatal error.
  $url = file_create_url($file);
  if ($exception !== NULL) {
    drupal_set_message(t('A fatal error occurred during the export process. See the errorlog for details, accessible via !url.', array(
      '!url' => l(t('this URL'), $url),
        )), 'error');
  }
  // Notify user about file copy errors.
  else {
    drupal_set_message(t('Some files were not copied. See the errorlog for details, accessible via !url.', array(
      '!url' => l(t('this URL'), $url),
        )), 'warning');
  }
}
